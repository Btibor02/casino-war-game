<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Game API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Game</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys, time
sys.path.append(&#34;.&#34;)

from CardMechanics import Card as cardClass
from CardMechanics import Deck as deckClass
from CardMechanics import CardHand as cardHandClass

from GameMechanics import Bet as betClass
from GameMechanics import Scores as scoresClass
from GameMechanics import UI as uiClass

from Players import Intelligence as intellClass
from Players import Player as playerClass

class Game:
    &#34;&#34;&#34;Creates a deck with shuffled cards&#34;&#34;&#34;
    cards = cardClass.Card()
    deck = deckClass.Deck(cards)
    shuffledDeck = deck.shuffleDeck()
    cardHand = cardHandClass.CardHand(shuffledDeck)
    bet = betClass.Bet()
    scores = scoresClass.Scores()

    gameGoing = True
    # get previous scores from the cache
    scores.update()

    def regularGame():
        &#34;&#34;&#34;Prints out Main menu&#34;&#34;&#34;
        Game.gameGoing = True
        menuResults = uiClass.Menu.callMenu()
        playerName = menuResults[0]
        difficulty = menuResults[1]

        &#34;&#34;&#34;Creates player and AI object&#34;&#34;&#34;
        player = playerClass.Player(playerName)
        playerBalance = player.get_balance()
        Game.scores.add_player(player)

        ai = intellClass.Intelligence(Game.shuffledDeck, 1000)
        aiBalance = intellClass.Intelligence.getAiBalance(ai)

        
        while Game.gameGoing:
            betAmount = uiClass.BetUI.bet(playerBalance)

            &#34;&#34;&#34;Exit midgame&#34;&#34;&#34;
            if betAmount == 0:
                Game.gameGoing = False
            else:
                &#34;&#34;&#34;Checks if there are enough card left in deck&#34;&#34;&#34;
                enoughCards = Game.cardHand.enoughCardsInDeck(Game.shuffledDeck)
                if enoughCards:
                    &#34;&#34;&#34;Draws a card for both the player and ai&#34;&#34;&#34;
                    draws = Game.cardHand.drawCard(Game.shuffledDeck)
                    playerHand = draws[0]
                    aiHand = draws[1]
                    shuffledDeck = draws[2]

                    &#34;&#34;&#34;Calls &#39;whosCardIsHigher&#39; method and returned values gets assigned to variables&#34;&#34;&#34;
                    results = Game.whosCardIsHigher(playerName, playerHand, aiHand, playerBalance, aiBalance, betAmount, shuffledDeck, difficulty, ai, aiDecision=3)
                    playerBalance = results[0]
                    shuffledDeck = results[1]
                    aiBalance = results[2]
                    indicator = results[3]
                    aiDecision = results[4]

                    # update the score of the player
                    Game.scores.update_player_balance(player, playerBalance)

                    &#34;&#34;&#34;Prints out table&#34;&#34;&#34;
                    uiClass.TableUI.table(playerName, playerHand, aiHand, playerBalance, aiBalance)
                    
                    &#34;&#34;&#34;If the outcome is not a tie, writes out who won&#34;&#34;&#34;
                    if indicator != &#34;Draw&#34;:
                        uiClass.midGameVisuals.winIndecator(indicator)
                    
                    &#34;&#34;&#34;If the outcome is a tie, writes out ai&#39;s decision&#34;&#34;&#34;
                    if aiDecision != 3:
                        uiClass.midGameVisuals.aiAction(aiDecision)
                else:
                    &#34;&#34;&#34;No card left in the deck&#34;&#34;&#34;
                    Game.gameGoing = False
                    uiClass.EndGameUI.noCardsLeft(playerBalance)
                    Game.startGameAgain() 

            &#34;&#34;&#34;Game ending scenarios&#34;&#34;&#34;
            if playerBalance &lt;= 0:
                &#34;&#34;&#34;Player lost all of its balance&#34;&#34;&#34; 
                Game.gameGoing = False
                uiClass.EndGameUI.zeroBalance()
                Game.startGameAgain()

            elif aiBalance &lt;= 0:
                &#34;&#34;&#34;Ai lost all of its balance&#34;&#34;&#34;
                Game.gameGoing = False
                uiClass.EndGameUI.aiZeroBalance()

                # add 1000$ to the balance because he won
                Game.scores.update_player_balance(player, playerBalance + 1000)

                Game.startGameAgain()
        
        Game.gameGoing = False
        menuResults = uiClass.Menu.callMenu()
    
    &#34;&#34;&#34;Check if AI has enough balance&#34;&#34;&#34;
    def aiHasEnoughBalance(betAmount, aiBalance):
        allInCheck = betClass.Bet.goAllIn(Game.bet, aiBalance, betAmount)
        aiBetAmount = allInCheck[0]

        return aiBetAmount



    &#34;&#34;&#34;Decides who won the round&#34;&#34;&#34;
    def whosCardIsHigher(playerName, playerHand, aiHand, playerBalance, aiBalance, betAmount, shuffledDeck, difficulty, ai, aiDecision):
        indicator = True
        uiClass.TableUI.table(playerName, playerHand, aiHand, playerBalance, aiBalance)

        aiBetAmount = Game.aiHasEnoughBalance(betAmount, aiBalance)

        &#34;&#34;&#34;Round outcomes&#34;&#34;&#34;
        if playerHand[1] &gt; aiHand[1]:
            &#34;&#34;&#34;Player won&#34;&#34;&#34;
            playerBalance = Game.bet.cardHigher(playerBalance, betAmount)
            aiBalance = Game.bet.cardLower(aiBalance, aiBetAmount)

            return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision
        
        elif aiHand[1] &gt; playerHand[1]:
            &#34;&#34;&#34;Ai won&#34;&#34;&#34;
            indicator = False
            playerBalance = Game.bet.cardLower(playerBalance, betAmount)
            aiBalance = Game.bet.cardHigher(aiBalance, aiBetAmount)

            return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision
        
        elif playerHand[1] == aiHand[1]:
            &#34;&#34;&#34;Checks if there are enough cards for a war&#34;&#34;&#34;
            enoughCardsForWar = Game.cardHand.enoughCardsInDeckWar(Game.shuffledDeck)
            if enoughCardsForWar:
                &#34;&#34;&#34;Its a tie, &#39;tie&#39; method gets called&#34;&#34;&#34;
                results = Game.tie(playerName, betAmount, playerBalance, aiBalance, shuffledDeck, difficulty, ai)

                return results
            else:
                print(&#34;Not enough cards left in deck to initiate war! Bets refunded&#34;)
                time.sleep(5)
                indicator = &#34;Draw&#34;
                return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision

    &#34;&#34;&#34;Checks wether the player or the AI would like to go to war&#34;&#34;&#34;
    def tie(playerName, betAmount, playerBalance, aiBalance, shuffledDeck, difficulty, ai):
        choice = uiClass.BetUI.war()

        &#34;&#34;&#34;Checks if player has enough balance to go to war&#34;&#34;&#34;
        if choice.upper() == &#34;WAR&#34;:
            hasEnoughBalance = betClass.Bet.enoughBalance(Game.bet, betAmount*2, playerBalance)
            if not hasEnoughBalance:
                print(&#34;You don&#39;t have enough balance to go to war! You must surrend!&#34;)
                time.sleep(5)
                choice = &#34;SURREND&#34;

        &#34;&#34;&#34;Checks if AI has enough balance to go to war&#34;&#34;&#34;       
        aiHasEnoughBalance = betClass.Bet.enoughBalance(Game.bet, betAmount*2, aiBalance)
        if not aiHasEnoughBalance:
            print(&#34;AI doesn&#39;t have enough balance to go to war! It must surrend!&#34;)
            time.sleep(5)
            aiChoice = True
        else:
            &#34;&#34;&#34;AI decision based on the selected difficulty&#34;&#34;&#34;
            if difficulty == &#34;Easy&#34;:
                aiChoice = intellClass.Intelligence.decideSurrenderEasyMode(ai)
            else:
                aiChoice = intellClass.Intelligence.decideSurrenderMediumMode(ai, shuffledDeck)

        aiBetAmount = Game.aiHasEnoughBalance(betAmount, aiBalance)

        &#34;&#34;&#34;Outcomes&#34;&#34;&#34;
        if choice.upper() == &#34;WAR&#34;:
            &#34;&#34;&#34;Player chose to go to war&#34;&#34;&#34;
            if aiChoice == False:
                &#34;&#34;&#34;AI chose to go to war&#34;&#34;&#34;
                aiDecision = 0
                betAmount = Game.bet.war(betAmount)
                shuffledDeck = Game.deck.burnCard(shuffledDeck)
                draws = Game.cardHand.drawCard(shuffledDeck)

                playerHand = draws[0]
                aiHand = draws[1]
                shuffledDeck = draws[2]
                uiClass.TableUI.table(playerName, playerHand, aiHand, playerBalance, aiBalance)
                
                results = Game.whosCardIsHigher(playerName, playerHand, aiHand, playerBalance, aiBalance, betAmount, shuffledDeck, difficulty, ai, aiDecision)
                playerBalance = results[0]
                shuffledDeck = results[1]
                aiBalance = results[2]
                indicator = results[3]

            elif aiChoice == True:
                &#34;&#34;&#34;AI chose to surrend&#34;&#34;&#34;
                aiDecision = 1
                playerBalance += betAmount * 1.5
                aiBalance = Game.bet.surrend(aiBalance, aiBetAmount)
                indicator = &#34;Draw&#34;

            return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision


        elif choice.upper() == &#34;SURREND&#34;:
            &#34;&#34;&#34;Player chose to surrend&#34;&#34;&#34;
            if aiChoice == False:
                &#34;&#34;&#34;AI chose to go to war&#34;&#34;&#34;
                aiDecision = 0
                aiBalance += aiBetAmount * 1.5
                playerBalance = Game.bet.surrend(playerBalance, betAmount)
                indicator = &#34;Draw&#34;

            else:
                &#34;&#34;&#34;AI chose to surrend&#34;&#34;&#34;
                aiDecision = 1
                playerBalance = Game.bet.surrend(playerBalance, betAmount)
                aiBalance = Game.bet.surrend(aiBalance, aiBetAmount)
                indicator = &#34;Draw&#34;

            return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision

    &#34;&#34;&#34;Start the game again from the beginning&#34;&#34;&#34;
    def startGameAgain():
        # save scores to cache (object serialization)
        Game.scores.save()
        Game.gameGoing = False

        choice = input(print(&#34;Would you like to start again? (y/n): &#34;))
        if choice == &#34;y&#34;:
            Game.shuffledDeck = Game.deck.shuffleDeck()
            Game.regularGame()
            
    

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Game.Game"><code class="flex name class">
<span>class <span class="ident">Game</span></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a deck with shuffled cards</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Game:
    &#34;&#34;&#34;Creates a deck with shuffled cards&#34;&#34;&#34;
    cards = cardClass.Card()
    deck = deckClass.Deck(cards)
    shuffledDeck = deck.shuffleDeck()
    cardHand = cardHandClass.CardHand(shuffledDeck)
    bet = betClass.Bet()
    scores = scoresClass.Scores()

    gameGoing = True
    # get previous scores from the cache
    scores.update()

    def regularGame():
        &#34;&#34;&#34;Prints out Main menu&#34;&#34;&#34;
        Game.gameGoing = True
        menuResults = uiClass.Menu.callMenu()
        playerName = menuResults[0]
        difficulty = menuResults[1]

        &#34;&#34;&#34;Creates player and AI object&#34;&#34;&#34;
        player = playerClass.Player(playerName)
        playerBalance = player.get_balance()
        Game.scores.add_player(player)

        ai = intellClass.Intelligence(Game.shuffledDeck, 1000)
        aiBalance = intellClass.Intelligence.getAiBalance(ai)

        
        while Game.gameGoing:
            betAmount = uiClass.BetUI.bet(playerBalance)

            &#34;&#34;&#34;Exit midgame&#34;&#34;&#34;
            if betAmount == 0:
                Game.gameGoing = False
            else:
                &#34;&#34;&#34;Checks if there are enough card left in deck&#34;&#34;&#34;
                enoughCards = Game.cardHand.enoughCardsInDeck(Game.shuffledDeck)
                if enoughCards:
                    &#34;&#34;&#34;Draws a card for both the player and ai&#34;&#34;&#34;
                    draws = Game.cardHand.drawCard(Game.shuffledDeck)
                    playerHand = draws[0]
                    aiHand = draws[1]
                    shuffledDeck = draws[2]

                    &#34;&#34;&#34;Calls &#39;whosCardIsHigher&#39; method and returned values gets assigned to variables&#34;&#34;&#34;
                    results = Game.whosCardIsHigher(playerName, playerHand, aiHand, playerBalance, aiBalance, betAmount, shuffledDeck, difficulty, ai, aiDecision=3)
                    playerBalance = results[0]
                    shuffledDeck = results[1]
                    aiBalance = results[2]
                    indicator = results[3]
                    aiDecision = results[4]

                    # update the score of the player
                    Game.scores.update_player_balance(player, playerBalance)

                    &#34;&#34;&#34;Prints out table&#34;&#34;&#34;
                    uiClass.TableUI.table(playerName, playerHand, aiHand, playerBalance, aiBalance)
                    
                    &#34;&#34;&#34;If the outcome is not a tie, writes out who won&#34;&#34;&#34;
                    if indicator != &#34;Draw&#34;:
                        uiClass.midGameVisuals.winIndecator(indicator)
                    
                    &#34;&#34;&#34;If the outcome is a tie, writes out ai&#39;s decision&#34;&#34;&#34;
                    if aiDecision != 3:
                        uiClass.midGameVisuals.aiAction(aiDecision)
                else:
                    &#34;&#34;&#34;No card left in the deck&#34;&#34;&#34;
                    Game.gameGoing = False
                    uiClass.EndGameUI.noCardsLeft(playerBalance)
                    Game.startGameAgain() 

            &#34;&#34;&#34;Game ending scenarios&#34;&#34;&#34;
            if playerBalance &lt;= 0:
                &#34;&#34;&#34;Player lost all of its balance&#34;&#34;&#34; 
                Game.gameGoing = False
                uiClass.EndGameUI.zeroBalance()
                Game.startGameAgain()

            elif aiBalance &lt;= 0:
                &#34;&#34;&#34;Ai lost all of its balance&#34;&#34;&#34;
                Game.gameGoing = False
                uiClass.EndGameUI.aiZeroBalance()

                # add 1000$ to the balance because he won
                Game.scores.update_player_balance(player, playerBalance + 1000)

                Game.startGameAgain()
        
        Game.gameGoing = False
        menuResults = uiClass.Menu.callMenu()
    
    &#34;&#34;&#34;Check if AI has enough balance&#34;&#34;&#34;
    def aiHasEnoughBalance(betAmount, aiBalance):
        allInCheck = betClass.Bet.goAllIn(Game.bet, aiBalance, betAmount)
        aiBetAmount = allInCheck[0]

        return aiBetAmount



    &#34;&#34;&#34;Decides who won the round&#34;&#34;&#34;
    def whosCardIsHigher(playerName, playerHand, aiHand, playerBalance, aiBalance, betAmount, shuffledDeck, difficulty, ai, aiDecision):
        indicator = True
        uiClass.TableUI.table(playerName, playerHand, aiHand, playerBalance, aiBalance)

        aiBetAmount = Game.aiHasEnoughBalance(betAmount, aiBalance)

        &#34;&#34;&#34;Round outcomes&#34;&#34;&#34;
        if playerHand[1] &gt; aiHand[1]:
            &#34;&#34;&#34;Player won&#34;&#34;&#34;
            playerBalance = Game.bet.cardHigher(playerBalance, betAmount)
            aiBalance = Game.bet.cardLower(aiBalance, aiBetAmount)

            return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision
        
        elif aiHand[1] &gt; playerHand[1]:
            &#34;&#34;&#34;Ai won&#34;&#34;&#34;
            indicator = False
            playerBalance = Game.bet.cardLower(playerBalance, betAmount)
            aiBalance = Game.bet.cardHigher(aiBalance, aiBetAmount)

            return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision
        
        elif playerHand[1] == aiHand[1]:
            &#34;&#34;&#34;Checks if there are enough cards for a war&#34;&#34;&#34;
            enoughCardsForWar = Game.cardHand.enoughCardsInDeckWar(Game.shuffledDeck)
            if enoughCardsForWar:
                &#34;&#34;&#34;Its a tie, &#39;tie&#39; method gets called&#34;&#34;&#34;
                results = Game.tie(playerName, betAmount, playerBalance, aiBalance, shuffledDeck, difficulty, ai)

                return results
            else:
                print(&#34;Not enough cards left in deck to initiate war! Bets refunded&#34;)
                time.sleep(5)
                indicator = &#34;Draw&#34;
                return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision

    &#34;&#34;&#34;Checks wether the player or the AI would like to go to war&#34;&#34;&#34;
    def tie(playerName, betAmount, playerBalance, aiBalance, shuffledDeck, difficulty, ai):
        choice = uiClass.BetUI.war()

        &#34;&#34;&#34;Checks if player has enough balance to go to war&#34;&#34;&#34;
        if choice.upper() == &#34;WAR&#34;:
            hasEnoughBalance = betClass.Bet.enoughBalance(Game.bet, betAmount*2, playerBalance)
            if not hasEnoughBalance:
                print(&#34;You don&#39;t have enough balance to go to war! You must surrend!&#34;)
                time.sleep(5)
                choice = &#34;SURREND&#34;

        &#34;&#34;&#34;Checks if AI has enough balance to go to war&#34;&#34;&#34;       
        aiHasEnoughBalance = betClass.Bet.enoughBalance(Game.bet, betAmount*2, aiBalance)
        if not aiHasEnoughBalance:
            print(&#34;AI doesn&#39;t have enough balance to go to war! It must surrend!&#34;)
            time.sleep(5)
            aiChoice = True
        else:
            &#34;&#34;&#34;AI decision based on the selected difficulty&#34;&#34;&#34;
            if difficulty == &#34;Easy&#34;:
                aiChoice = intellClass.Intelligence.decideSurrenderEasyMode(ai)
            else:
                aiChoice = intellClass.Intelligence.decideSurrenderMediumMode(ai, shuffledDeck)

        aiBetAmount = Game.aiHasEnoughBalance(betAmount, aiBalance)

        &#34;&#34;&#34;Outcomes&#34;&#34;&#34;
        if choice.upper() == &#34;WAR&#34;:
            &#34;&#34;&#34;Player chose to go to war&#34;&#34;&#34;
            if aiChoice == False:
                &#34;&#34;&#34;AI chose to go to war&#34;&#34;&#34;
                aiDecision = 0
                betAmount = Game.bet.war(betAmount)
                shuffledDeck = Game.deck.burnCard(shuffledDeck)
                draws = Game.cardHand.drawCard(shuffledDeck)

                playerHand = draws[0]
                aiHand = draws[1]
                shuffledDeck = draws[2]
                uiClass.TableUI.table(playerName, playerHand, aiHand, playerBalance, aiBalance)
                
                results = Game.whosCardIsHigher(playerName, playerHand, aiHand, playerBalance, aiBalance, betAmount, shuffledDeck, difficulty, ai, aiDecision)
                playerBalance = results[0]
                shuffledDeck = results[1]
                aiBalance = results[2]
                indicator = results[3]

            elif aiChoice == True:
                &#34;&#34;&#34;AI chose to surrend&#34;&#34;&#34;
                aiDecision = 1
                playerBalance += betAmount * 1.5
                aiBalance = Game.bet.surrend(aiBalance, aiBetAmount)
                indicator = &#34;Draw&#34;

            return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision


        elif choice.upper() == &#34;SURREND&#34;:
            &#34;&#34;&#34;Player chose to surrend&#34;&#34;&#34;
            if aiChoice == False:
                &#34;&#34;&#34;AI chose to go to war&#34;&#34;&#34;
                aiDecision = 0
                aiBalance += aiBetAmount * 1.5
                playerBalance = Game.bet.surrend(playerBalance, betAmount)
                indicator = &#34;Draw&#34;

            else:
                &#34;&#34;&#34;AI chose to surrend&#34;&#34;&#34;
                aiDecision = 1
                playerBalance = Game.bet.surrend(playerBalance, betAmount)
                aiBalance = Game.bet.surrend(aiBalance, aiBetAmount)
                indicator = &#34;Draw&#34;

            return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision

    &#34;&#34;&#34;Start the game again from the beginning&#34;&#34;&#34;
    def startGameAgain():
        # save scores to cache (object serialization)
        Game.scores.save()
        Game.gameGoing = False

        choice = input(print(&#34;Would you like to start again? (y/n): &#34;))
        if choice == &#34;y&#34;:
            Game.shuffledDeck = Game.deck.shuffleDeck()
            Game.regularGame()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="Game.Game.bet"><code class="name">var <span class="ident">bet</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Game.Game.cardHand"><code class="name">var <span class="ident">cardHand</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Game.Game.cards"><code class="name">var <span class="ident">cards</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Game.Game.deck"><code class="name">var <span class="ident">deck</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Game.Game.gameGoing"><code class="name">var <span class="ident">gameGoing</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Game.Game.scores"><code class="name">var <span class="ident">scores</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Game.Game.shuffledDeck"><code class="name">var <span class="ident">shuffledDeck</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Game.Game.aiHasEnoughBalance"><code class="name flex">
<span>def <span class="ident">aiHasEnoughBalance</span></span>(<span>betAmount, aiBalance)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aiHasEnoughBalance(betAmount, aiBalance):
    allInCheck = betClass.Bet.goAllIn(Game.bet, aiBalance, betAmount)
    aiBetAmount = allInCheck[0]

    return aiBetAmount</code></pre>
</details>
</dd>
<dt id="Game.Game.regularGame"><code class="name flex">
<span>def <span class="ident">regularGame</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints out Main menu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regularGame():
    &#34;&#34;&#34;Prints out Main menu&#34;&#34;&#34;
    Game.gameGoing = True
    menuResults = uiClass.Menu.callMenu()
    playerName = menuResults[0]
    difficulty = menuResults[1]

    &#34;&#34;&#34;Creates player and AI object&#34;&#34;&#34;
    player = playerClass.Player(playerName)
    playerBalance = player.get_balance()
    Game.scores.add_player(player)

    ai = intellClass.Intelligence(Game.shuffledDeck, 1000)
    aiBalance = intellClass.Intelligence.getAiBalance(ai)

    
    while Game.gameGoing:
        betAmount = uiClass.BetUI.bet(playerBalance)

        &#34;&#34;&#34;Exit midgame&#34;&#34;&#34;
        if betAmount == 0:
            Game.gameGoing = False
        else:
            &#34;&#34;&#34;Checks if there are enough card left in deck&#34;&#34;&#34;
            enoughCards = Game.cardHand.enoughCardsInDeck(Game.shuffledDeck)
            if enoughCards:
                &#34;&#34;&#34;Draws a card for both the player and ai&#34;&#34;&#34;
                draws = Game.cardHand.drawCard(Game.shuffledDeck)
                playerHand = draws[0]
                aiHand = draws[1]
                shuffledDeck = draws[2]

                &#34;&#34;&#34;Calls &#39;whosCardIsHigher&#39; method and returned values gets assigned to variables&#34;&#34;&#34;
                results = Game.whosCardIsHigher(playerName, playerHand, aiHand, playerBalance, aiBalance, betAmount, shuffledDeck, difficulty, ai, aiDecision=3)
                playerBalance = results[0]
                shuffledDeck = results[1]
                aiBalance = results[2]
                indicator = results[3]
                aiDecision = results[4]

                # update the score of the player
                Game.scores.update_player_balance(player, playerBalance)

                &#34;&#34;&#34;Prints out table&#34;&#34;&#34;
                uiClass.TableUI.table(playerName, playerHand, aiHand, playerBalance, aiBalance)
                
                &#34;&#34;&#34;If the outcome is not a tie, writes out who won&#34;&#34;&#34;
                if indicator != &#34;Draw&#34;:
                    uiClass.midGameVisuals.winIndecator(indicator)
                
                &#34;&#34;&#34;If the outcome is a tie, writes out ai&#39;s decision&#34;&#34;&#34;
                if aiDecision != 3:
                    uiClass.midGameVisuals.aiAction(aiDecision)
            else:
                &#34;&#34;&#34;No card left in the deck&#34;&#34;&#34;
                Game.gameGoing = False
                uiClass.EndGameUI.noCardsLeft(playerBalance)
                Game.startGameAgain() 

        &#34;&#34;&#34;Game ending scenarios&#34;&#34;&#34;
        if playerBalance &lt;= 0:
            &#34;&#34;&#34;Player lost all of its balance&#34;&#34;&#34; 
            Game.gameGoing = False
            uiClass.EndGameUI.zeroBalance()
            Game.startGameAgain()

        elif aiBalance &lt;= 0:
            &#34;&#34;&#34;Ai lost all of its balance&#34;&#34;&#34;
            Game.gameGoing = False
            uiClass.EndGameUI.aiZeroBalance()

            # add 1000$ to the balance because he won
            Game.scores.update_player_balance(player, playerBalance + 1000)

            Game.startGameAgain()
    
    Game.gameGoing = False
    menuResults = uiClass.Menu.callMenu()</code></pre>
</details>
</dd>
<dt id="Game.Game.startGameAgain"><code class="name flex">
<span>def <span class="ident">startGameAgain</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startGameAgain():
    # save scores to cache (object serialization)
    Game.scores.save()
    Game.gameGoing = False

    choice = input(print(&#34;Would you like to start again? (y/n): &#34;))
    if choice == &#34;y&#34;:
        Game.shuffledDeck = Game.deck.shuffleDeck()
        Game.regularGame()</code></pre>
</details>
</dd>
<dt id="Game.Game.tie"><code class="name flex">
<span>def <span class="ident">tie</span></span>(<span>playerName, betAmount, playerBalance, aiBalance, shuffledDeck, difficulty, ai)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tie(playerName, betAmount, playerBalance, aiBalance, shuffledDeck, difficulty, ai):
    choice = uiClass.BetUI.war()

    &#34;&#34;&#34;Checks if player has enough balance to go to war&#34;&#34;&#34;
    if choice.upper() == &#34;WAR&#34;:
        hasEnoughBalance = betClass.Bet.enoughBalance(Game.bet, betAmount*2, playerBalance)
        if not hasEnoughBalance:
            print(&#34;You don&#39;t have enough balance to go to war! You must surrend!&#34;)
            time.sleep(5)
            choice = &#34;SURREND&#34;

    &#34;&#34;&#34;Checks if AI has enough balance to go to war&#34;&#34;&#34;       
    aiHasEnoughBalance = betClass.Bet.enoughBalance(Game.bet, betAmount*2, aiBalance)
    if not aiHasEnoughBalance:
        print(&#34;AI doesn&#39;t have enough balance to go to war! It must surrend!&#34;)
        time.sleep(5)
        aiChoice = True
    else:
        &#34;&#34;&#34;AI decision based on the selected difficulty&#34;&#34;&#34;
        if difficulty == &#34;Easy&#34;:
            aiChoice = intellClass.Intelligence.decideSurrenderEasyMode(ai)
        else:
            aiChoice = intellClass.Intelligence.decideSurrenderMediumMode(ai, shuffledDeck)

    aiBetAmount = Game.aiHasEnoughBalance(betAmount, aiBalance)

    &#34;&#34;&#34;Outcomes&#34;&#34;&#34;
    if choice.upper() == &#34;WAR&#34;:
        &#34;&#34;&#34;Player chose to go to war&#34;&#34;&#34;
        if aiChoice == False:
            &#34;&#34;&#34;AI chose to go to war&#34;&#34;&#34;
            aiDecision = 0
            betAmount = Game.bet.war(betAmount)
            shuffledDeck = Game.deck.burnCard(shuffledDeck)
            draws = Game.cardHand.drawCard(shuffledDeck)

            playerHand = draws[0]
            aiHand = draws[1]
            shuffledDeck = draws[2]
            uiClass.TableUI.table(playerName, playerHand, aiHand, playerBalance, aiBalance)
            
            results = Game.whosCardIsHigher(playerName, playerHand, aiHand, playerBalance, aiBalance, betAmount, shuffledDeck, difficulty, ai, aiDecision)
            playerBalance = results[0]
            shuffledDeck = results[1]
            aiBalance = results[2]
            indicator = results[3]

        elif aiChoice == True:
            &#34;&#34;&#34;AI chose to surrend&#34;&#34;&#34;
            aiDecision = 1
            playerBalance += betAmount * 1.5
            aiBalance = Game.bet.surrend(aiBalance, aiBetAmount)
            indicator = &#34;Draw&#34;

        return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision


    elif choice.upper() == &#34;SURREND&#34;:
        &#34;&#34;&#34;Player chose to surrend&#34;&#34;&#34;
        if aiChoice == False:
            &#34;&#34;&#34;AI chose to go to war&#34;&#34;&#34;
            aiDecision = 0
            aiBalance += aiBetAmount * 1.5
            playerBalance = Game.bet.surrend(playerBalance, betAmount)
            indicator = &#34;Draw&#34;

        else:
            &#34;&#34;&#34;AI chose to surrend&#34;&#34;&#34;
            aiDecision = 1
            playerBalance = Game.bet.surrend(playerBalance, betAmount)
            aiBalance = Game.bet.surrend(aiBalance, aiBetAmount)
            indicator = &#34;Draw&#34;

        return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision</code></pre>
</details>
</dd>
<dt id="Game.Game.whosCardIsHigher"><code class="name flex">
<span>def <span class="ident">whosCardIsHigher</span></span>(<span>playerName, playerHand, aiHand, playerBalance, aiBalance, betAmount, shuffledDeck, difficulty, ai, aiDecision)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def whosCardIsHigher(playerName, playerHand, aiHand, playerBalance, aiBalance, betAmount, shuffledDeck, difficulty, ai, aiDecision):
    indicator = True
    uiClass.TableUI.table(playerName, playerHand, aiHand, playerBalance, aiBalance)

    aiBetAmount = Game.aiHasEnoughBalance(betAmount, aiBalance)

    &#34;&#34;&#34;Round outcomes&#34;&#34;&#34;
    if playerHand[1] &gt; aiHand[1]:
        &#34;&#34;&#34;Player won&#34;&#34;&#34;
        playerBalance = Game.bet.cardHigher(playerBalance, betAmount)
        aiBalance = Game.bet.cardLower(aiBalance, aiBetAmount)

        return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision
    
    elif aiHand[1] &gt; playerHand[1]:
        &#34;&#34;&#34;Ai won&#34;&#34;&#34;
        indicator = False
        playerBalance = Game.bet.cardLower(playerBalance, betAmount)
        aiBalance = Game.bet.cardHigher(aiBalance, aiBetAmount)

        return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision
    
    elif playerHand[1] == aiHand[1]:
        &#34;&#34;&#34;Checks if there are enough cards for a war&#34;&#34;&#34;
        enoughCardsForWar = Game.cardHand.enoughCardsInDeckWar(Game.shuffledDeck)
        if enoughCardsForWar:
            &#34;&#34;&#34;Its a tie, &#39;tie&#39; method gets called&#34;&#34;&#34;
            results = Game.tie(playerName, betAmount, playerBalance, aiBalance, shuffledDeck, difficulty, ai)

            return results
        else:
            print(&#34;Not enough cards left in deck to initiate war! Bets refunded&#34;)
            time.sleep(5)
            indicator = &#34;Draw&#34;
            return playerBalance, shuffledDeck, aiBalance, indicator, aiDecision</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Game.Game" href="#Game.Game">Game</a></code></h4>
<ul class="two-column">
<li><code><a title="Game.Game.aiHasEnoughBalance" href="#Game.Game.aiHasEnoughBalance">aiHasEnoughBalance</a></code></li>
<li><code><a title="Game.Game.bet" href="#Game.Game.bet">bet</a></code></li>
<li><code><a title="Game.Game.cardHand" href="#Game.Game.cardHand">cardHand</a></code></li>
<li><code><a title="Game.Game.cards" href="#Game.Game.cards">cards</a></code></li>
<li><code><a title="Game.Game.deck" href="#Game.Game.deck">deck</a></code></li>
<li><code><a title="Game.Game.gameGoing" href="#Game.Game.gameGoing">gameGoing</a></code></li>
<li><code><a title="Game.Game.regularGame" href="#Game.Game.regularGame">regularGame</a></code></li>
<li><code><a title="Game.Game.scores" href="#Game.Game.scores">scores</a></code></li>
<li><code><a title="Game.Game.shuffledDeck" href="#Game.Game.shuffledDeck">shuffledDeck</a></code></li>
<li><code><a title="Game.Game.startGameAgain" href="#Game.Game.startGameAgain">startGameAgain</a></code></li>
<li><code><a title="Game.Game.tie" href="#Game.Game.tie">tie</a></code></li>
<li><code><a title="Game.Game.whosCardIsHigher" href="#Game.Game.whosCardIsHigher">whosCardIsHigher</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>